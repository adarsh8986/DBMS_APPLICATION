<?xml version="1.0" encoding="utf-8"?>
<ScrollView xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:layout_margin="8dp"
    android:scrollbars="none"
    tools:context="urgroup.in.dbmssqlcompleteguide.button12">

    <LinearLayout
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:orientation="vertical">

        <TextView
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:layout_weight="1"
            android:text="DBMS - Normalization"
            android:textAlignment="center"
            android:textColor="#000000"
            android:textSize="30dp" />

        <TextView
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:layout_weight="1"
            android:text="Functional Dependency"
            android:textAlignment="center"
            android:textColor="#000000"
            android:textSize="30dp" />

        <TextView
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:layout_marginTop="14dp"
            android:layout_weight="1"
            android:text="Functional dependency (FD) is a set of constraints between two attributes in a relation. Functional dependency says that if two tuples have same values for attributes A1, A2,..., An, then those two tuples must have to have same values for attributes B1, B2, ..., Bn."
            android:textColor="#008080"
            android:textSize="19dp" />

        <TextView
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:layout_marginTop="14dp"
            android:layout_weight="1"
            android:text="Functional dependency is represented by an arrow sign (→) that is, X→Y, where X functionally determines Y. The left-hand side attributes determine the values of attributes on the right-hand side."
            android:textColor="#008080"
            android:textSize="19dp" />

        <TextView
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:layout_weight="1"
            android:text="Armstrong's Axioms"
            android:textAlignment="center"
            android:textColor="#000000"
            android:textSize="30dp" />

        <TextView
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:layout_marginTop="14dp"
            android:layout_weight="1"
            android:text="If F is a set of functional dependencies then the closure of F, denoted as F+, is the set of all functional dependencies logically implied by F. Armstrong's Axioms are a set of rules, that when applied repeatedly, generates a closure of functional dependencies."
            android:textColor="#008080"
            android:textSize="19dp" />

        <TableLayout
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:layout_marginTop="14dp">

            <TableRow>

                <TextView
                    android:layout_column="1"
                    android:text="•"
                    android:textSize="23dp"></TextView>

                <TextView
                    android:layout_width="wrap_content"
                    android:layout_column="2"
                    android:text="Reflexive rule − If alpha is a set of attributes and beta is_subset_of alpha, then alpha holds beta."
                    android:textColor="#008080"
                    android:textSize="19dp"></TextView>
            </TableRow>

            <TableRow>

                <TextView
                    android:layout_column="1"
                    android:text="•"
                    android:textSize="23dp"></TextView>

                <TextView
                    android:layout_width="wrap_content"
                    android:layout_column="2"
                    android:text="Augmentation rule − If a → b holds and y is attribute set, then ay → by also holds. That is adding attributes in dependencies, does not change the basic dependencies."
                    android:textColor="#008080"
                    android:textSize="19dp"></TextView>
            </TableRow>

            <TableRow>

                <TextView
                    android:layout_column="1"
                    android:text="•"
                    android:textSize="23dp"></TextView>

                <TextView
                    android:layout_width="wrap_content"
                    android:layout_column="2"
                    android:text="Transitivity rule − Same as transitive rule in algebra, if a → b holds and b → c holds, then a → c also holds. a → b is called as a functionally that determines b."
                    android:textColor="#008080"
                    android:textSize="19dp"></TextView>
            </TableRow>

        </TableLayout>


        <TextView
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:layout_weight="1"
            android:text="Trivial Functional Dependency"
            android:textAlignment="center"
            android:textColor="#000000"
            android:textSize="30dp" />

        <TableLayout
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:layout_marginTop="14dp">

            <TableRow>

                <TextView
                    android:layout_column="1"
                    android:text="•"
                    android:textSize="23dp"></TextView>

                <TextView
                    android:layout_width="wrap_content"
                    android:layout_column="2"
                    android:text="Trivial − If a functional dependency (FD) X → Y holds, where Y is a subset of X, then it is called a trivial FD. Trivial FDs always hold."
                    android:textColor="#008080"
                    android:textSize="19dp"></TextView>
            </TableRow>

            <TableRow>

                <TextView
                    android:layout_column="1"
                    android:text="•"
                    android:textSize="23dp"></TextView>

                <TextView
                    android:layout_width="wrap_content"
                    android:layout_column="2"
                    android:text="Non-trivial − If an FD X → Y holds, where Y is not a subset of X, then it is called a non-trivial FD."
                    android:textColor="#008080"
                    android:textSize="19dp"></TextView>
            </TableRow>

            <TableRow>

                <TextView
                    android:layout_column="1"
                    android:text="•"
                    android:textSize="23dp"></TextView>

                <TextView
                    android:layout_width="wrap_content"
                    android:layout_column="2"
                    android:text="Completely non-trivial − If an FD X → Y holds, where x intersect Y = Φ, it is said to be a completely non-trivial FD."
                    android:textColor="#008080"
                    android:textSize="19dp"></TextView>
            </TableRow>
        </TableLayout>

        <TextView
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:layout_weight="1"
            android:text="Normalization"
            android:textAlignment="center"
            android:textColor="#000000"
            android:textSize="30dp" />

        <TextView
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:layout_marginTop="14dp"
            android:layout_weight="1"
            android:text="If a database design is not perfect, it may contain anomalies, which are like a bad dream for any database administrator. Managing a database with anomalies is next to impossible."
            android:textColor="#008080"
            android:textSize="19dp" />

        <TableLayout
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:layout_marginTop="14dp">

            <TableRow>

                <TextView
                    android:layout_column="1"
                    android:text="•"
                    android:textSize="23dp"></TextView>

                <TextView
                    android:layout_width="wrap_content"
                    android:layout_column="2"
                    android:text="Update anomalies − If data items are scattered and are not linked to each other properly, then it could lead to strange situations. For example, when we try to update one data item having its copies scattered over several places, a few instances get updated properly while a few others are left with old values. Such instances leave the database in an inconsistent state."
                    android:textColor="#008080"
                    android:textSize="19dp"></TextView>
            </TableRow>

            <TableRow>

                <TextView
                    android:layout_column="1"
                    android:text="•"
                    android:textSize="23dp"></TextView>

                <TextView
                    android:layout_width="wrap_content"
                    android:layout_column="2"
                    android:text="Deletion anomalies − We tried to delete a record, but parts of it was left undeleted because of unawareness, the data is also saved somewhere else."
                    android:textColor="#008080"
                    android:textSize="19dp"></TextView>
            </TableRow>

            <TableRow>

                <TextView
                    android:layout_column="1"
                    android:text="•"
                    android:textSize="23dp"></TextView>

                <TextView
                    android:layout_width="wrap_content"
                    android:layout_column="2"
                    android:text="Insert anomalies − We tried to insert data in a record that does not exist at all."
                    android:textColor="#008080"
                    android:textSize="19dp"></TextView>
            </TableRow>
        </TableLayout>

        <TextView
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:layout_marginTop="14dp"
            android:layout_weight="1"
            android:text="Normalization is a method to remove all these anomalies and bring the database to a consistent state."
            android:textColor="#008080"
            android:textSize="19dp" />

        <TextView
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:layout_weight="1"
            android:text="First Normal Form"
            android:textAlignment="center"
            android:textColor="#000000"
            android:textSize="30dp" />

        <TextView
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:layout_marginTop="14dp"
            android:layout_weight="1"
            android:text="First Normal Form is defined in the definition of relations (tables) itself. This rule defines that all the attributes in a relation must have atomic domains. The values in an atomic domain are indivisible units."
            android:textColor="#008080"
            android:textSize="19dp" />

        <ImageView
            android:layout_width="wrap_content"
            android:layout_height="400dp"
            android:layout_marginTop="14dp"
            android:scaleType="fitXY"
            android:src="@drawable/unorganized_relation" />

        <TextView
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:layout_marginTop="14dp"
            android:layout_weight="1"
            android:text="We re-arrange the relation (table) as below, to convert it to First Normal Form."
            android:textColor="#008080"
            android:textSize="19dp" />

        <ImageView
            android:layout_width="wrap_content"
            android:layout_height="400dp"
            android:layout_marginTop="14dp"
            android:scaleType="fitXY"
            android:src="@drawable/run" />

        <TextView
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:layout_marginTop="14dp"
            android:layout_weight="1"
            android:text="Each attribute must contain only a single value from its pre-defined domain."
            android:textColor="#008080"
            android:textSize="19dp" />

        <TextView
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:layout_weight="1"
            android:text="Second Normal Form"
            android:textAlignment="center"
            android:textColor="#000000"
            android:textSize="30dp" />

        <TextView
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:layout_marginTop="14dp"
            android:layout_weight="1"
            android:text="Before we learn about the second normal form, we need to understand the following −"
            android:textColor="#008080"
            android:textSize="19dp" />

        <TableLayout
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:layout_marginTop="14dp">

            <TableRow>

                <TextView
                    android:layout_column="1"
                    android:text="•"
                    android:textSize="23dp"></TextView>

                <TextView
                    android:layout_width="wrap_content"
                    android:layout_column="2"
                    android:text="Prime attribute − An attribute, which is a part of the prime-key, is known as a prime attribute."
                    android:textColor="#008080"
                    android:textSize="19dp"></TextView>
            </TableRow>

            <TableRow>

                <TextView
                    android:layout_column="1"
                    android:text="•"
                    android:textSize="23dp"></TextView>

                <TextView
                    android:layout_width="wrap_content"
                    android:layout_column="2"
                    android:text="Non-prime attribute − An attribute, which is not a part of the prime-key, is said to be a non-prime attribute."
                    android:textColor="#008080"
                    android:textSize="19dp"></TextView>
            </TableRow>
        </TableLayout>


        <TextView
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:layout_marginTop="14dp"
            android:layout_weight="1"
            android:text="If we follow second normal form, then every non-prime attribute should be fully functionally dependent on prime key attribute. That is, if X → A holds, then there should not be any proper subset Y of X, for which Y → A also holds true."
            android:textColor="#008080"
            android:textSize="19dp" />

        <ImageView
            android:layout_width="wrap_content"
            android:layout_height="400dp"
            android:layout_marginTop="14dp"
            android:scaleType="fitXY"
            android:src="@drawable/not_nf" />


        <TextView
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:layout_marginTop="14dp"
            android:layout_weight="1"
            android:text="We see here in Student_Project relation that the prime key attributes are Stu_ID and Proj_ID. According to the rule, non-key attributes, i.e. Stu_Name and Proj_Name must be dependent upon both and not on any of the prime key attribute individually. But we find that Stu_Name can be identified by Stu_ID and Proj_Name can be identified by Proj_ID independently. This is called partial dependency, which is not allowed in Second Normal Form."
            android:textColor="#008080"
            android:textSize="19dp" />

        <ImageView
            android:layout_width="wrap_content"
            android:layout_height="400dp"
            android:layout_marginTop="14dp"
            android:scaleType="fitXY"
            android:src="@drawable/nf" />

        <TextView
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:layout_marginTop="14dp"
            android:layout_weight="1"
            android:text="We broke the relation in two as depicted in the above picture. So there exists no partial dependency."
            android:textColor="#008080"
            android:textSize="19dp" />

        <TextView
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:layout_weight="1"
            android:text="Third Normal Form"
            android:textAlignment="center"
            android:textColor="#000000"
            android:textSize="30dp" />

        <TextView
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:layout_marginTop="14dp"
            android:layout_weight="1"
            android:text="For a relation to be in Third Normal Form, it must be in Second Normal form and the following must satisfy −"
            android:textColor="#008080"
            android:textSize="19dp" />

        <TableLayout
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:layout_marginTop="14dp">

            <TableRow>

                <TextView
                    android:layout_column="1"
                    android:text="•"
                    android:textSize="23dp"></TextView>

                <TextView
                    android:layout_width="wrap_content"
                    android:layout_column="2"
                    android:text="No non-prime attribute is transitively dependent on prime key attribute."
                    android:textColor="#008080"
                    android:textSize="19dp"></TextView>
            </TableRow>

            <TableRow>

                <TextView
                    android:layout_column="1"
                    android:text="•"
                    android:textSize="23dp"></TextView>

                <TextView
                    android:layout_width="wrap_content"
                    android:layout_column="2"
                    android:text="For any non-trivial functional dependency, X → A, then either −
\n X is a superkey or,\n A is prime attribute."
                    android:textColor="#008080"
                    android:textSize="19dp"></TextView>
            </TableRow>
        </TableLayout>


        <ImageView
            android:layout_width="wrap_content"
            android:layout_height="400dp"
            android:layout_marginTop="14dp"
            android:scaleType="fitXY"
            android:src="@drawable/not_3nf" />

        <TextView
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:layout_marginTop="14dp"
            android:layout_weight="1"
            android:text="We find that in the above Student_detail relation, Stu_ID is the key and only prime key attribute. We find that City can be identified by Stu_ID as well as Zip itself. Neither Zip is a superkey nor is City a prime attribute. Additionally, Stu_ID → Zip → City, so there exists transitive dependency.

\n \n To bring this relation into third normal form, we break the relation into two relations as follows −"
            android:textColor="#008080"
            android:textSize="19dp" />

        <ImageView
            android:layout_width="wrap_content"
            android:layout_height="400dp"
            android:layout_marginTop="14dp"
            android:scaleType="fitXY"
            android:src="@drawable/nf3" />

        <TextView
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:layout_weight="1"
            android:text="Boyce-Codd Normal Form"
            android:textAlignment="center"
            android:textColor="#000000"
            android:textSize="30dp" />

        <TextView
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:layout_marginTop="14dp"
            android:layout_weight="1"
            android:text="Boyce-Codd Normal Form (BCNF) is an extension of Third Normal Form on strict terms. BCNF states that −

\n For any non-trivial functional dependency, X → A, X must be a super-key.

\n
In the above image, Stu_ID is the super-key in the relation Student_Detail and Zip is the super-key in the relation ZipCodes. So,
\n Stu_ID → Stu_Name, Zip
\n  and   Zip → City  \n Which confirms that both the relations are in BCNF.

"
            android:textColor="#008080"
            android:textSize="19dp" />


    </LinearLayout>
</ScrollView>
